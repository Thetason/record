import { NextRequest, NextResponse } from 'next/server';
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import crypto from 'crypto';
import sharp from 'sharp';
import { LRUCache } from 'lru-cache';
import cleanKoreanReview, { stripCommonNoiseLines as stripNoiseLocal, normalizeWhitespacePunct as normPunct } from '@/lib/text-clean';
import { improveSpacingViaService } from '@/lib/spacing-service';
import { rateLimit, getIP, rateLimitResponse, apiLimits } from '@/lib/rate-limit';
const vision = require('@google-cloud/vision');

// Google Vision API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
let visionClient: any = null;
const cache = new LRUCache<string, any>({ max: 500, ttl: 1000 * 60 * 60 * 24 * 7 });
const enableTesseractFallback = process.env.ENABLE_TESSERACT_FALLBACK === 'true';
const visionTimeoutMs = Number(process.env.OCR_VISION_TIMEOUT_MS || 18000);
const limiter = rateLimit({ interval: 60 * 1000, uniqueTokenPerInterval: 500 });

function withTimeout<T>(promise: Promise<T>, ms: number, label: string): Promise<T> {
  if (!ms || Number.isNaN(ms) || ms <= 0) {
    return promise;
  }
  return new Promise<T>((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`TIMEOUT_${label}_${ms}`));
    }, ms);

    promise
      .then(value => {
        clearTimeout(timer);
        resolve(value);
      })
      .catch(error => {
        clearTimeout(timer);
        reject(error);
      });
  });
}

// Ï¥àÍ∏∞Ìôî Ìï®Ïàò
async function initializeVisionClient() {
  if (visionClient) return visionClient;
  
  try {
    console.log('Vision API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
    console.log('GOOGLE_APPLICATION_CREDENTIALS:', process.env.GOOGLE_APPLICATION_CREDENTIALS);
    
    // Base64 Ïù∏ÏΩîÎî©Îêú ÌÇ§Í∞Ä ÏûàÎäî Í≤ΩÏö∞ (Vercel ÌîÑÎ°úÎçïÏÖò)
    if (process.env.GOOGLE_VISION_API_KEY) {
      console.log('Base64 ÌÇ§ ÏÇ¨Ïö©');
      const credentials = JSON.parse(
        Buffer.from(process.env.GOOGLE_VISION_API_KEY, 'base64').toString()
      );
      visionClient = new vision.ImageAnnotatorClient({
        credentials,
        projectId: credentials.project_id,
      });
    } 
    // Î°úÏª¨ JSON ÌååÏùº Í≤ΩÎ°úÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ (Í∞úÎ∞ú ÌôòÍ≤Ω)
    else if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {
      console.log('Î°úÏª¨ ÌÇ§ ÌååÏùº ÏÇ¨Ïö©:', process.env.GOOGLE_APPLICATION_CREDENTIALS);
      visionClient = new vision.ImageAnnotatorClient({
        keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS
      });
    }
    
    if (visionClient) {
      console.log('‚úÖ Vision API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ');
    } else {
      console.log('‚ùå Vision API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî Ïã§Ìå®');
    }
  } catch (error) {
    console.error('‚ùå Google Vision API Ï¥àÍ∏∞Ìôî ÏóêÎü¨:', error);
  }
  
  return visionClient;
}

export async function POST(req: NextRequest) {
  let lastUploadedBuffer: Buffer | null = null;
  try {
    // Feature flag: allow disabling OCR and always return mock
    const ocrEnabled = process.env.ENABLE_OCR !== 'false';
    console.log('üì∏ OCR API Ìò∏Ï∂úÎê®');

    if (!ocrEnabled) {
      return NextResponse.json(
        {
          success: false,
          error: 'OCR Í∏∞Îä•Ïù¥ ÌòÑÏû¨ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.'
        },
        { status: 503 }
      );
    }

    // Rate limiting (per IP)
    const clientIp = getIP(req) || 'unknown';
    try {
      await limiter.check(req, apiLimits.ocr, `ocr_${clientIp}`);
    } catch {
      return rateLimitResponse(60);
    }

    // Ïù∏Ï¶ù ÌôïÏù∏
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        {
          success: false,
          error: 'Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.'
        },
        { status: 401 }
      );
    }

    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Ï°∞Ìöå
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { id: true, plan: true, reviewLimit: true }
    });

    if (!user) {
      return NextResponse.json(
        {
          success: false,
          error: 'ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.'
        },
        { status: 404 }
      );
    }

    // ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞ ÌååÏã±
    let formData;
    try {
      formData = await req.formData();
    } catch (parseError) {
      console.error('FormData ÌååÏã± ÏóêÎü¨:', parseError);
      return NextResponse.json(
        { 
          success: false,
          error: 'ÏûòÎ™ªÎêú ÏöîÏ≤≠ ÌòïÏãùÏûÖÎãàÎã§.' 
        },
        { status: 400 }
      );
    }
    
    const image = formData.get('image') as File;
    
    if (!image) {
      return NextResponse.json(
        { 
          success: false,
          error: 'Ïù¥ÎØ∏ÏßÄÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.' 
        },
        { status: 400 }
      );
    }

    // Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞ Ï≤¥ÌÅ¨ (10MB Ï†úÌïú)
    if (image.size > 10 * 1024 * 1024) {
      return NextResponse.json(
        { 
          success: false,
          error: 'Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞Îäî 10MB Ïù¥ÌïòÏó¨Ïïº Ìï©ÎãàÎã§.' 
        },
        { status: 400 }
      );
    }

    // Build cache key from image hash
    const bufRaw = Buffer.from(await image.arrayBuffer());
    lastUploadedBuffer = bufRaw;
    const hash = crypto.createHash('sha256').update(bufRaw).digest('hex');
    const cached = cache.get(hash);
    if (cached) {
      return NextResponse.json({ success: true, data: cached, cache: true });
    }

    // Preprocess image to improve OCR
    let processed = bufRaw;
    try {
      const img = sharp(bufRaw).resize({ width: 1600, withoutEnlargement: true }).grayscale().normalize();
      // optional threshold to reduce UI noise; avoid over-binarization for photos
      processed = await img.toBuffer();
    } catch {}

    // Vision API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
    const client = ocrEnabled ? await initializeVisionClient() : null;
    
    // Vision APIÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Mock Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
    if (!client) {
      console.log('Google Vision APIÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå. Mock Îç∞Ïù¥ÌÑ∞ Î∞òÌôò');
      
      // Í∞úÎ∞úÏö© Mock Îç∞Ïù¥ÌÑ∞
      const mockData = {
        text: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5.0\n\nÏ†ïÎßê ÎßåÏ°±Ïä§Îü¨Ïö¥ ÏÑúÎπÑÏä§ÏòÄÏäµÎãàÎã§!\nÏÑ†ÏÉùÎãòÏù¥ ÎÑàÎ¨¥ ÏπúÏ†àÌïòÏãúÍ≥† Ï†ÑÎ¨∏Ï†ÅÏù¥ÏÑ∏Ïöî.\nÎã§ÏùåÏóêÎèÑ Íº≠ Îã§Ïãú Ï∞æÍ≥† Ïã∂ÏäµÎãàÎã§.\n\n2024ÎÖÑ 12Ïõî 15Ïùº\nÎÑ§Ïù¥Î≤Ñ Î¶¨Î∑∞',
        platform: 'naver',
        rating: 5,
        date: '2024-12-15',
        confidence: 0.95
      };
      
      return NextResponse.json({
        success: true,
        data: mockData,
        mock: true,
        message: 'OCR APIÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïÑ ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Î•º Î∞òÌôòÌï©ÎãàÎã§.'
      });
    }

    // Ïù¥ÎØ∏ÏßÄÎ•º BufferÎ°ú Î≥ÄÌôò
    const buffer = processed;

    // Google Vision API Ìò∏Ï∂ú
    console.log(`üîç Vision API Ìò∏Ï∂ú ÏãúÏûë... (timeout: ${visionTimeoutMs}ms)`);
    // Prefer documentTextDetection to get structured blocks/paragraphs/words
    const [result] = await withTimeout(
      client.documentTextDetection({
        image: { content: buffer.toString('base64') },
        imageContext: { languageHints: ['ko', 'en'] }
      }),
      visionTimeoutMs,
      'VISION'
    );

    // Try Google's assembled text first
    const full = result.fullTextAnnotation?.text?.trim();
    // Fallback to annotations array
    const detections = result.textAnnotations;
    
    if (!full && (!detections || detections.length === 0)) {
      // Try Tesseract fallback before giving up (load lazily to avoid worker bundling issues)
      if (enableTesseractFallback) {
        try {
          const { default: Tesseract } = await import('tesseract.js');
          const tess = await Tesseract.recognize(buffer, 'kor+eng');
          const tText = (tess?.data?.text || '').trim();
          if (tText) {
            const cleanedT = cleanKoreanReview(stripNoiseLocal(refineSpacing(tText)), { maskPII: true, strong: true });
            const tExtract = analyzeReviewText(cleanedT);
            const payload = {
              ...tExtract,
              text: cleanedT,
              rawText: tText,
              normalizedText: cleanedT,
              confidence: 0.7,
              engine: 'tesseract',
              postprocess: 'local'
            }
            cache.set(hash, payload);
            return NextResponse.json({ success: true, data: payload });
          }
        } catch (e) {
          console.warn('Tesseract fallback failed or unavailable:', e);
        }
      } else {
        console.warn('Tesseract fallback ÎπÑÌôúÏÑ±ÌôîÎê® (ENABLE_TESSERACT_FALLBACK !== "true")');
      }
      return NextResponse.json({ success: false, error: 'ÌÖçÏä§Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' }, { status: 422 });
    }
    
    // Rebuild text in reading order when Google's assembled text is noisy
    const rebuilt = rebuildReadingOrder(result);
    const rawFullText = (rebuilt || full || detections?.[0]?.description || '').trim();
    // Local cleaning
    const normalization = await normalizeForAnalysis(rawFullText);
    let baseForCleaner = normalization.baseText;
    // External cleaner (optional)
    let cleaned = baseForCleaner;
    let externalApplied = false;
    const svc = process.env.TEXT_CLEAN_SERVICE_URL;
    if (svc) {
      try {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), 2000);
        const resp = await fetch(svc, { method: 'POST', body: JSON.stringify({ text: baseForCleaner }), headers: { 'Content-Type': 'application/json' }, signal: ctrl.signal });
        clearTimeout(t);
        if (resp.ok) {
          const j: any = await resp.json();
          const external = (j.cleaned || j.text);
          if (external && typeof external === 'string') {
            cleaned = external;
            externalApplied = true;
          }
        }
      } catch {}
    }

    // Final safety normalization
    cleaned = cleanKoreanReview(cleaned, { maskPII: true, strong: true });
    
    // ÌÖçÏä§Ìä∏ Î∂ÑÏÑù Î∞è Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú(Spacing ÏÑúÎπÑÏä§ Ï†ÅÏö© Í≤∞Í≥º Í∏∞Ï§Ä)
    const extractedData = analyzeReviewText(baseForCleaner);

    // OCR ÏÇ¨Ïö© Í∏∞Î°ù Ï†ÄÏû• (ÏûÑÏãú ÎπÑÌôúÏÑ±Ìôî)
    /*
    await prisma.activityLog.create({
      data: {
        userId: user.id,
        action: 'OCR_SCAN',
        category: 'review',
        details: {
          platform: extractedData.platform,
          rating: extractedData.rating,
          textLength: fullText.length
        }
      }
    });
    */

    const postSteps: string[] = [];
    if (normalization.spacingApplied) postSteps.push('spacing-service');
    if (externalApplied) postSteps.push('external');
    postSteps.push('local');

    const payload = {
      ...extractedData,
      text: cleaned,
      rawText: rawFullText,
      normalizedText: cleaned,
      confidence: (Array.isArray(detections) && detections[0] && (detections[0] as any).confidence) ? (detections[0] as any).confidence : 0.9,
      engine: 'google',
      postprocess: postSteps.join('+'),
      intermediateText: {
        denoised: normalization.denoised,
        base: baseForCleaner
      }
    }
    cache.set(hash, payload);
    return NextResponse.json({ success: true, data: payload });

  } catch (error) {
    console.error('OCR Ï≤òÎ¶¨ ÏóêÎü¨:', error);
    if (enableTesseractFallback && error instanceof Error && error.message?.startsWith('TIMEOUT_VISION')) {
      console.error('Vision API timeout Î∞úÏÉù, Tesseract fallback ÏãúÎèÑ');
    }
    if (enableTesseractFallback && lastUploadedBuffer) {
      try {
        const { default: Tesseract } = await import('tesseract.js');
        const tess = await Tesseract.recognize(lastUploadedBuffer, 'kor+eng');
        const tText = (tess?.data?.text || '').trim();
        if (tText) {
          const normalization = await normalizeForAnalysis(tText);
          let baseForCleaner = normalization.baseText;
          let cleanedT = baseForCleaner;
          let externalApplied = false;

          if (process.env.TEXT_CLEAN_SERVICE_URL) {
            try {
              const ctrl = new AbortController();
              const t = setTimeout(() => ctrl.abort(), 2000);
              const resp = await fetch(process.env.TEXT_CLEAN_SERVICE_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: baseForCleaner }),
                signal: ctrl.signal
              });
              clearTimeout(t);
              if (resp.ok) {
                const j: any = await resp.json();
                const external = (j.cleaned || j.text);
                if (external && typeof external === 'string') {
                  cleanedT = external;
                  externalApplied = true;
                }
              }
            } catch {}
          }

          cleanedT = cleanKoreanReview(cleanedT, { maskPII: true, strong: true });
          const tExtract = analyzeReviewText(baseForCleaner);
          const postSteps = [] as string[];
          if (normalization.spacingApplied) postSteps.push('spacing-service');
          if (externalApplied) postSteps.push('external');
          postSteps.push('local');
          const payload = {
            ...tExtract,
            text: cleanedT,
            rawText: tText,
            normalizedText: cleanedT,
            confidence: 0.7,
            engine: 'tesseract',
            postprocess: postSteps.join('+'),
            intermediateText: {
              denoised: normalization.denoised,
              base: baseForCleaner
            }
          }
          return NextResponse.json({ success: true, data: payload });
        }
      } catch (e) {
        console.warn('Tesseract final fallback failed or unavailable:', e);
      }
    }
    return NextResponse.json({ success: false, error: 'OCR Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.' }, { status: 504 });
  }
}

// ÌÖçÏä§Ìä∏ÏóêÏÑú Î¶¨Î∑∞ Ï†ïÎ≥¥ Ï∂îÏ∂ú
function analyzeReviewText(text: string) {
  const cleaned = normalizeText(text);
  // ÌîåÎû´Ìèº Í∞êÏßÄ
  let platform = 'unknown';
  if (
    cleaned.includes('ÎÑ§Ïù¥Î≤Ñ') || cleaned.includes('NAVER') ||
    /Î¶¨Î∑∞\s*[\d,]+.*ÏÇ¨ÏßÑ\s*[\d,]+/.test(cleaned) ||
    /^ÌåîÎ°úÏö∞$/m.test(cleaned)
  ) {
    platform = 'naver';
  } else if (text.includes('Ïπ¥Ïπ¥Ïò§') || text.includes('kakao')) {
    platform = 'kakao';
  } else if (text.includes('Ïù∏Ïä§ÌÉÄÍ∑∏Îû®') || text.includes('Instagram')) {
    platform = 'instagram';
  } else if (text.includes('Íµ¨Í∏Ä') || text.includes('Google')) {
    platform = 'google';
  }

  // ÌèâÏ†ê Ï∂îÏ∂ú (Î≥ÑÏ†ê ÎòêÎäî Ïà´Ïûê)
  let rating = 5;
  const starMatch = cleaned.match(/‚≠ê+/);
  if (starMatch) {
    rating = starMatch[0].length;
  } else {
    const ratingMatch = cleaned.match(/(\d+(?:\.\d+)?)\s*(?:Ï†ê|\/\s*5)/);
    if (ratingMatch) {
      rating = Math.min(5, Math.max(1, parseFloat(ratingMatch[1])));
    }
  }

  // ÎÇ†Ïßú Ï∂îÏ∂ú
  let date = new Date().toISOString().split('T')[0];
  const datePatterns = [
    /(\d{4})[ÎÖÑ.-](\d{1,2})[Ïõî.-](\d{1,2})/,
    /(\d{1,2})[Ïõî.-](\d{1,2})[Ïùº]/,
    /(\d{4})\.(\d{1,2})\.(\d{1,2})/,
    /(\d{1,2})\.(\d{1,2})(?:\.(?:Ïõî|\w+))?/,
    /(\d{1,2})\s*Ïùº\s*Ï†Ñ/, // 3Ïùº Ï†Ñ
    /(Ïñ¥Ï†ú|Í∑∏Ï†ú)/
  ];
  
  for (const pattern of datePatterns) {
    const dateMatch = cleaned.match(pattern);
    if (dateMatch) {
      if (pattern.source.includes('Ïùº\\s*Ï†Ñ')) {
        const days = parseInt(dateMatch[1], 10) || 0;
        const d = new Date();
        d.setDate(d.getDate() - days);
        date = d.toISOString().split('T')[0];
      } else if (dateMatch[1] === 'Ïñ¥Ï†ú' || dateMatch[1] === 'Í∑∏Ï†ú') {
        const delta = dateMatch[1] === 'Ïñ¥Ï†ú' ? 1 : 2;
        const d = new Date();
        d.setDate(d.getDate() - delta);
        date = d.toISOString().split('T')[0];
      } else {
        const y = dateMatch[1];
        const year = y && y.length === 4 ? y : String(new Date().getFullYear());
        const month = (dateMatch[2] || dateMatch[1]).toString();
        const day = (dateMatch[3] || dateMatch[2]).toString();
        date = `${month.length === 1 && year === String(new Date().getFullYear()) && !dateMatch[3] ? year : year}-${month.padStart(2,'0')}-${day.padStart(2,'0')}`;
      }
      break;
    }
  }

  // ÏûëÏÑ±ÏûêÎ™Ö Ï∂îÏ∂ú (ÏÑ†ÌÉùÏ†Å)
  let author = '';
  const authorPatterns = [
    /ÏûëÏÑ±Ïûê\s*[:Ôºö]\s*([^\n]+)/,
    /ÎãâÎÑ§ÏûÑ\s*[:Ôºö]\s*([^\n]+)/,
    /([Í∞Ä-Ìû£A-Za-z0-9*]{2,15})\s*Îãò/
  ];
  
  for (const pattern of authorPatterns) {
    const authorMatch = cleaned.match(pattern);
    if (authorMatch) {
      author = authorMatch[1].trim();
      break;
    }
  }

  // ÎÑ§Ïù¥Î≤Ñ Ï†ÑÏö© ÌååÏÑú: ÏÉÅÎã® Î©îÌÉÄ/ÌåîÎ°úÏö∞/Ï†ëÍ∏∞/ÌïòÎã® ÌÉúÍ∑∏ Ï†úÍ±∞, Î≥∏Î¨∏Îßå Ï∂îÏ∂ú
  let body = cleaned;
  let business = '';
  if (platform === 'naver') {
    const n = parseNaver(cleaned);
    author = n.author || author;
    date = n.date || date;
    body = n.body || cleaned;
    business = n.business || '';
  } else if (platform === 'kakao') {
    const k = parseKakao(cleaned);
    author = k.author || author;
    date = k.date || date;
    body = k.body || cleaned;
  } else {
    body = parseGeneric(cleaned);
  }

  return {
    platform,
    rating,
    date,
    author,
    business,
    reviewText: body
  };
}

function normalizeText(s: string): string {
  return s
    .replace(/\r\n?/g, '\n')
    .replace(/[\t\f\v]+/g, ' ')
    .replace(/ +/g, ' ')
    .replace(/[\u200B-\u200D\uFEFF]/g, '')
    .trim();
}

// Í≥µÌÜµ UI ÎÖ∏Ïù¥Ï¶à ÎùºÏù∏ Ï†úÍ±∞(ÌîåÎû´Ìèº Í≥µÌÜµ ÏöîÏÜåÎì§)
function stripCommonNoiseLines(text: string): string {
  const rawLines = text.split('\n').map(l => l.trim());
  const uiWords = [
    'ÌåîÎ°úÏö∞','ÌåîÎ°úÏûâ','ÌîÑÎ°úÌïÑ','Î≤àÏó≠','Í≥µÏú†','Ïã†Í≥†','Ï†ëÍ∏∞','ÎçîÎ≥¥Í∏∞','ÏßÄÎèÑÎ≥¥Í∏∞','Í∏∏Ï∞æÍ∏∞','Ï†ÑÌôî',
    'Ï¢ãÏïÑÏöî','ÎåìÍ∏Ä','Î©îÎâ¥','ÏÇ¨Ïû•Îãò','ÏÇ¨Ïû•Îãò ÎåìÍ∏Ä','ÎãµÍ∏Ä','Í¥ÄÏã¨',
  ];
  const isSymbolOnly = (s: string) => s.length <= 3 && /^[^\wÍ∞Ä-Ìû£]+$/.test(s);
  const filtered = rawLines.filter(l => l && !uiWords.some(w => l === w || l.includes(w)) && !isSymbolOnly(l));
  // ÏÉÅÎã® Í≥†Ï†ï Ìó§Îçî ÏòÅÏó≠ Ïª∑(ÌÖçÏä§Ìä∏ ÏÉÅÎã® 10% Í∞ÄÏ†ï)
  // ÌÖçÏä§Ìä∏ Í∏∞Î∞ò Ïª∑Ïù¥ÎØÄÎ°ú Ï≤´ 2~3Ï§ÑÏóê ÎÖ∏Ïù¥Ï¶àÍ∞Ä Î™∞Î¶¥ Îïå Ï†úÍ±∞
  const startIdx = Math.min(3, Math.floor(filtered.length * 0.1));
  return filtered.slice(startIdx).join('\n').trim();
}

function parseNaver(text: string): { author: string; body: string; date: string; business: string } {
  const rawLines = text.split('\n').map(l => l.trim());
  const lines = rawLines.filter(Boolean);
  let author = '';
  let date = '';
  let business = '';

  // ÌõÑÎ≥¥: Ï≤´ Ï§Ñ(ÎßàÏä§ÌÇπ Ïù¥Î¶Ñ), ÌòπÏùÄ "ÏûëÏÑ±Ïûê: xxx"
  const top = lines[0] || '';
  if (/^[A-Za-z0-9Í∞Ä-Ìû£*]{2,15}$/.test(top)) author = top;
  const authorLine = lines.find(l => /ÏûëÏÑ±Ïûê\s*[:Ôºö]/.test(l));
  if (authorLine) {
    const m = authorLine.match(/[:Ôºö]\s*(.+)$/);
    if (m) author = m[1].trim();
  }

  // Î¶¨Î∑∞/ÏÇ¨ÏßÑ/ÌåîÎ°úÏö∞ Îì± ÏÉÅÎã® Î©îÌÉÄ Ï†úÍ±∞ + ÏÉÅÎã® ÎÑ§ÎπÑ/ÏãúÍ≥Ñ/Ïã¨Î≥º ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞
  const noiseTop = [
    /^Î¶¨Î∑∞\s*\d+(?:Í∞ú)?$/,
    /^ÏÇ¨ÏßÑ\s*\d+(?:Ïû•)?$/,
    /^ÌåîÎ°úÏö∞(?:\s*\+?\d+)?$/i,
    /^ÌåîÎ°úÏûâ$/,
    /^ÌîÑÎ°úÌïÑ$/,
    /^ÌõÑÍ∏∞\s*Î™®ÏïÑÎ≥¥Í∏∞$/,
    /^(Ìôà\s*)(ÏÜåÏãù)?\s*(ÏòàÏïΩ)?\s*(Î¶¨Î∑∞)?$/,
    /^Ï£ºÎ≥Ä$/,
    /^Ï†ïÎ≥¥$/,
    /^ÏßÄÎèÑÎ≥¥Í∏∞?$/,
    /^Í∏∏Ï∞æÍ∏∞$/,
    /^Ï†ÑÌôî$/,
    /^Ï†ÄÏû•$/
  ];
  let start = 0;
  const isSymbolOnly = (s: string) => /^[^\wÍ∞Ä-Ìû£]+$/.test(s);
  const looksLikeClock = (s: string) => /\d{1,2}:\d{2}/.test(s);
  const looksLikeNetwork = (s: string) => /(5G|LTE|wifi|Wi-?Fi|X)/i.test(s);

  for (let i = 0; i < lines.length; i++) {
    const l = lines[i];
    if (i === 0 && author && l === author) { start = i + 1; continue; }
    if (noiseTop.some(r => r.test(l))) { start = i + 1; continue; }
    if (/^\[[^\]]+\]$/.test(l)) { start = i + 1; continue; } // Ïπ¥ÌÖåÍ≥†Î¶¨ ÌÉúÍ∑∏ [Î≥¥Ïª¨, ÎØ∏Îîî]
    if (/^Î¶¨Î∑∞\s*[\d,]+\s*[.,¬∑]\s*ÏÇ¨ÏßÑ\s*[\d,]+$/.test(l)) { start = i + 1; continue; }
    // Ïó∞ÏÜçÏ†ÅÏúºÎ°ú Î©îÌÉÄÎßå ÏûàÎäî Íµ¨Í∞Ñ Ïä§ÌÇµ
    if (i <= 6 && (l.length <= 3 || /^(ÌåîÎ°úÏö∞|ÌåîÎ°úÏûâ)$/.test(l) || isSymbolOnly(l) || looksLikeClock(l) || looksLikeNetwork(l))) { start = i + 1; continue; }
    break;
  }

  // ÌïòÎã® ÎÖ∏Ïù¥Ï¶à(Ï†ëÍ∏∞/ÏãúÏÑ§ ÌÉúÍ∑∏Î•ò) Ïª∑Ïò§ÌîÑ
  const bottomNoise = [
    'Ï†ëÍ∏∞', 'ÎçîÎ≥¥Í∏∞', 'Î≤àÏó≠', 'Í≥µÏú†', 'Ïã†Í≥†', 'Î©îÎâ¥', 'ÎãµÍ∏Ä', 'ÏÇ¨Ïû•Îãò', 'ÏÇ¨Ïû•Îãò ÎåìÍ∏Ä',
    'ÏãúÏÑ§Ïù¥ ÍπîÎÅîÌï¥Ïöî', 'ÏïÑÎäëÌï¥Ïöî', 'Ïã§Î†•Ïù¥', 'ÏπúÏ†àÌï¥Ïöî', 'Ïû¨Î∞©Î¨∏', 'Ï∂îÏ≤ú', 'Í∞ÄÏÑ±ÎπÑÍ∞Ä Ï¢ãÏïÑÏöî',
  ];
  let end = lines.length;
  for (let i = start; i < lines.length; i++) {
    if (lines[i] === 'Ï†ëÍ∏∞') { end = i; break; }
    if (bottomNoise.some(k => lines[i].includes(k)) && (i - start) > 1) { end = i; break; }
  }

  // Î≥∏Î¨∏ ÌõÑÎ≥¥
  let bodyLines = lines.slice(start, end);
  // Ï§ëÍ∞ÑÏóê ÎÅºÏñ¥Îì† ÌïòÌä∏/Î∂àÎ¶ø/Îã®Ïñ¥ ÌÉúÍ∑∏ Ï†ïÎ¶¨
  bodyLines = bodyLines.filter(l => !/^[‚Ä¢‚ô°‚ô•‚Äª‚ñ∂¬∑„Üç]+/.test(l));
  // ÏßßÏùÄ ÌÉúÍ∑∏ÏÑ± ÎùºÏù∏ Ï†úÍ±∞(2~4Í∏ÄÏûê, ‚ÄòÌï¥Ïöî/Ï¢ãÏïÑÏöî/ÍπîÎÅî/ÏïÑÎäë‚Äô Îì± ÌÇ§ÏõåÎìú Ìè¨Ìï®)
  const tagHints = ['Ìï¥Ïöî', 'Ï¢ãÏïÑÏöî', 'ÍπîÎÅî', 'ÏïÑÎäë', 'Ïû¨Î∞©Î¨∏', 'Ï∂îÏ≤ú', 'ÏπúÏ†à', 'Ïã§Î†•', 'Í∞ÄÏÑ±ÎπÑ'];
  bodyLines = bodyLines.filter(l => !(l.length <= 6 && tagHints.some(k => l.includes(k))));
  // ÎÇ†Ïßú ÌõÑÎ≥¥Î•º Î≥∏Î¨∏ ÏÉÅÌïòÎã®ÏóêÏÑú ÌÉêÏÉâ
  const dateLine = bodyLines.find(l => /(\d{4}[.\-]\d{1,2}[.\-]\d{1,2})|(\d{1,2}[.\-]\d{1,2})|(\d+\s*Ïùº\s*Ï†Ñ)|(Ïñ¥Ï†ú|Í∑∏Ï†ú)/.test(l))
    || rawLines.reverse().find(l => /(\d{4}|\d{2})[.\-]\d{1,2}[.\-]\d{1,2}/.test(l));
  if (dateLine) {
    const d = analyzeReviewText(dateLine).date; // reuse
    if (d) date = d;
    // ÎÇ†ÏßúÎßå ÏûàÎäî ÎùºÏù∏ÏùÄ Î≥∏Î¨∏ÏóêÏÑú Ï†úÍ±∞
    bodyLines = bodyLines.filter(l => l !== dateLine);
  }

  // ÏûîÏó¨ ÎÖ∏Ïù¥Ï¶à ÎùºÏù∏ ÌïÑÌÑ∞
  bodyLines = bodyLines.filter(l => !/^Î¶¨Î∑∞\s*\d+|^ÏÇ¨ÏßÑ\s*\d+|^ÌåîÎ°úÏö∞/.test(l));
  // Ï∂îÍ∞Ä ÎÖ∏Ïù¥Ï¶à: Îã®Ïùº Í∏∞Ìò∏/Î≥Ñ/Î¨ºÏùåÌëú/Îã®ÎèÖ X ÎùºÏù∏ ÏÇ≠Ï†ú
  bodyLines = bodyLines.filter(l => !/^(\?|x|X|‚òÜ|‚òÖ|\*|\-|=|‚Äî|¬∑|„Üç)$/.test(l));

  // ÎπÑÏ¶àÎãàÏä§Î™Ö ÌõÑÎ≥¥: ÏÉÅÎã® Í∑ºÏ≤òÏùò ÌïúÍµ≠Ïñ¥ Ï§ëÏã¨ ÎùºÏù∏ Ï§ë ÎÖ∏Ïù¥Ï¶à Ï†úÏô∏, ÌäπÏ†ï ÌÇ§ÏõåÎìú Ìè¨Ìï® Ïö∞ÏÑ†
  const bizKeywords = ['ÌïôÏõê','ÌÅ¥ÎûòÏä§','Ïä§ÌäúÎîîÏò§','ÏÑºÌÑ∞','ÏÉµ','ÎÆ§ÏßÅ','ÌïÑÎùºÌÖåÏä§','PT','Î∑∞Ìã∞','Ìó§Ïñ¥','ÎÑ§Ïùº','ÏöîÍ∞Ä','Î≥¥Ïª¨'];
  const isNoise = (s: string) => /^(Ìôà|Î¶¨Î∑∞|ÏÇ¨ÏßÑ|Ï†ïÎ≥¥|ÏßÄÎèÑ|Í∏∏Ï∞æÍ∏∞|Ï†ÑÌôî|Ï†ÄÏû•|Í≥µÏú†|Î¶¨Î∑∞\s|ÏÇ¨ÏßÑ\s|ÌåîÎ°úÏö∞|ÌåîÎ°úÏûâ|ÌîÑÎ°úÌïÑ|ÌõÑÍ∏∞\s*Î™®ÏïÑÎ≥¥Í∏∞)$/.test(s);
  const topWindow = lines.slice(0, Math.min(lines.length, 12));
  const bizCandidates = topWindow
    .filter(l => !isNoise(l) && /[Í∞Ä-Ìû£]{2,}/.test(l) && l.length <= 30)
    .map(l => ({ l, score: bizKeywords.some(k => l.includes(k)) ? 2 : 1 }))
    .sort((a,b)=> b.score - a.score || b.l.length - a.l.length);
  if (bizCandidates[0]) business = bizCandidates[0].l.replace(/[‚Ä†‚Ä°‚òÖ‚òÜ‚ú©‚ú≠‚úÆ‚úØ‚≠êÔ∏è]+/g,'').trim();

  const body = bodyLines.join('\n').trim();
  return { author, body, date, business };
}

// Kakao style: ÏÉÅÎã® ÎãâÎÑ§ÏûÑ/Î≥ÑÏ†ê/Î∞©Î¨∏ÏùºÏûê, ÌïòÎã® "ÏßÄÎèÑÎ≥¥Í∏∞/Í≥µÏú†/Ïã†Í≥†" ÎòêÎäî "Ï¢ãÏïÑÏöî"Î•ò Ï†úÍ±∞
function parseKakao(text: string): { author: string; body: string; date: string } {
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
  let author = '';
  let date = '';

  // Ï≤´ Ï§Ñ ÎãâÎÑ§ÏûÑ ÎòêÎäî "ÏûëÏÑ±Ïûê:"
  const top = lines[0] || '';
  if (/^[A-Za-z0-9Í∞Ä-Ìû£*]{2,15}$/.test(top)) author = top;
  const authorLine = lines.find(l => /ÏûëÏÑ±Ïûê\s*[:Ôºö]/.test(l));
  if (authorLine) author = authorLine.split(/[:Ôºö]/)[1]?.trim() || author;

  // ÏÉÅÎã® Î©îÌÉÄ/Î≤ÑÌäº Ï†úÍ±∞
  const topNoise = [/^ÏßÄÎèÑÎ≥¥Í∏∞$/, /^Í≥µÏú†$/, /^Ïã†Í≥†$/, /^Ï¢ãÏïÑÏöî\s*\d*$/, /^ÌåîÎ°úÏö∞$/];
  let start = 0;
  for (let i = 0; i < lines.length; i++) {
    if (i <= 2 && (lines[i] === author || topNoise.some(r => r.test(lines[i])))) {
      start = i + 1; continue;
    }
    break;
  }

  // ÌïòÎã® ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞
  const bottomNoise = ['ÎçîÎ≥¥Í∏∞', 'Ï†ëÍ∏∞', 'Í≥µÏú†', 'Ïã†Í≥†', 'Î≤àÏó≠', 'Ï¢ãÏïÑÏöî'];
  let end = lines.length;
  for (let i = start; i < lines.length; i++) {
    if (bottomNoise.some(k => lines[i].includes(k)) && (i - start) > 1) { end = i; break; }
  }

  let bodyLines = lines.slice(start, end);
  // Î∞©Î¨∏Ïùº/ÏûëÏÑ±Ïùº Ï∂îÏ∂ú
  const dateLine = bodyLines.find(l => /(\d{4}[.\-]\d{1,2}[.\-]\d{1,2})|(\d{1,2}[.\-]\d{1,2})|(\d+\s*Ïùº\s*Ï†Ñ)|(Ïñ¥Ï†ú|Í∑∏Ï†ú)/.test(l));
  if (dateLine) {
    const d = analyzeReviewText(dateLine).date;
    if (d) date = d;
    bodyLines = bodyLines.filter(l => l !== dateLine);
  }

  // ÌÉúÍ∑∏/ÏÜçÏÑ± ÎùºÏù∏ Ï†úÍ±∞(Ïòà: Î∂ÑÏúÑÍ∏∞/ÏÑúÎπÑÏä§/Í∞ÄÍ≤©ÎåÄ Îì±)
  const attrHints = ['Î∂ÑÏúÑÍ∏∞', 'ÏÑúÎπÑÏä§', 'Í∞ÄÍ≤©', 'Î©îÎâ¥', 'Ï≤≠Í≤∞', 'ÏßÅÏõê', 'Ï∂îÏ≤ú'];
  bodyLines = bodyLines.filter(l => !attrHints.some(k => l.includes(k)));

  return { author, body: bodyLines.join('\n').trim(), date };
}

// Generic cleanup for platforms: drop common UI words
function parseGeneric(text: string): string {
  const lines = text.split('\n').map(l => l.trim()).filter(Boolean);
  const ui = ['Ï†ëÍ∏∞', 'ÎçîÎ≥¥Í∏∞', 'Í≥µÏú†', 'Ïã†Í≥†', 'Î≤àÏó≠', 'ÌåîÎ°úÏö∞', 'ÌîÑÎ°úÌïÑ'];
  return lines.filter(l => !ui.includes(l)).join('\n').trim();
}

// Heuristic re-ordering using geometry (blocks/paragraphs/words)
function rebuildReadingOrder(result: any): string | null {
  // Prefer paragraph-level reconstruction from fullTextAnnotation
  const pages = result.fullTextAnnotation?.pages || [];
  const lines: { x: number; y: number; text: string }[] = [];

  const getCenter = (vertices: any[]) => {
    const xs = vertices.map((v: any) => v.x || 0);
    const ys = vertices.map((v: any) => v.y || 0);
    const x = (Math.min(...xs) + Math.max(...xs)) / 2;
    const y = (Math.min(...ys) + Math.max(...ys)) / 2;
    const h = Math.max(...ys) - Math.min(...ys);
    return { x, y, h };
  };

  // Estimate page height for y-based trimming
  let pageMaxY = 0;
  for (const page of pages) {
    for (const block of page.blocks || []) {
      for (const para of block.paragraphs || []) {
        const words = (para.words || []).map((w: any) => (w.symbols || []).map((s: any) => s.text).join(''));
        const text = words.join(' ').trim();
        if (!text) continue;
        const { x, y } = getCenter(para.boundingBox?.vertices || []);
        pageMaxY = Math.max(pageMaxY, ...(para.boundingBox?.vertices || []).map((v: any) => v.y || 0));
        lines.push({ x, y, text });
      }
    }
  }

  // Fallback to word annotations if no paragraphs
  if (lines.length === 0 && Array.isArray(result.textAnnotations)) {
    const words = result.textAnnotations.slice(1).map((a: any) => {
      const { x, y, h } = getCenter(a.boundingPoly?.vertices || []);
      return { x, y, h, text: a.description };
    });
    if (words.length === 0) return null;
    // Group words into lines by similar Y (tolerance relative to word height)
    words.sort((a: any, b: any) => (a.y === b.y ? a.x - b.x : a.y - b.y));
    const grouped: { y: number; items: typeof words }[] = [];
    for (const w of words) {
      const band = grouped.find(g => Math.abs(g.y - w.y) <= Math.max(8, w.h * 0.6));
      if (band) {
        band.items.push(w);
        // keep representative y as average for stability
        band.y = (band.y * (band.items.length - 1) + w.y) / band.items.length;
      } else {
        grouped.push({ y: w.y, items: [w] });
      }
    }
    // Sort bands top->bottom, words left->right
    grouped.sort((a, b) => a.y - b.y);
    const rebuiltText = grouped
      .map(g => g.items.sort((a, b) => a.x - b.x).map(i => i.text).join(' '))
      .join('\n');
    return rebuiltText.trim();
  }

  // Simple multi-column handling: split by big x gaps if needed could be added later
  // Optional: cut fixed header region (top 12% by default)
  const cutRatio = Number(process.env.OCR_TOP_CUT_RATIO || 0.12);
  const yCut = pageMaxY ? pageMaxY * cutRatio : 0;
  const filtered = yCut ? lines.filter(l => l.y >= yCut) : lines;

  // Sort paragraph lines by y then x
  filtered.sort((a, b) => (a.y === b.y ? a.x - b.x : a.y - b.y));
  return filtered.map(l => l.text).join('\n').trim() || null;
}

// Post-OCR spacing refinement for Korean-heavy lines
function refineSpacing(text: string): string {
  return text.split('\n').map(line => {
    const tokens = line.trim().split(/\s+/);
    const hangul = /[\uAC00-\uD7AF]/;
    const singleHangul = tokens.filter(t => t.length === 1 && hangul.test(t)).length;
    const ratio = tokens.length ? singleHangul / tokens.length : 0;
    if (ratio >= 0.5) {
      // Collapse spaces between Hangul letters, keep punctuation spacing sane
      return line
        .replace(/(?<=[\uAC00-\uD7AF])\s+(?=[\uAC00-\uD7AF])/g, '')
        .replace(/\s+([,\.\!\?%\)\]\}])/g, '$1')
        .replace(/([\(\[\{])\s+/g, '$1');
    }
    return line;
  }).join('\n');
}

async function normalizeForAnalysis(raw: string) {
  const refined = refineSpacing(raw);
  const denoised = stripNoiseLocal(refined);
  const spaced = await improveSpacingViaService(denoised);
  const baseText = spaced ?? denoised;
  return {
    refined,
    denoised,
    baseText,
    spacingApplied: Boolean(spaced)
  };
}
